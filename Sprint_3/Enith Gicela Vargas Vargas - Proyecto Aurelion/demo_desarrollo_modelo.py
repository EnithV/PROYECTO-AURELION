#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DEMO ASINCR√ìNICA - DESARROLLO DEL MODELO - PROYECTO AURELION
=============================================================

**Autor:** Enith Gicela Vargas Vargas  
**Camada:** 1  
**Grupo:** 11  
**Fecha:** 2025-11-27  
**Curso:** AI Fundamentals - Guayerd - IBM Skills Build  
**Proyecto:** Aurelion - Demo Asincr√≥nica  
**M√≥dulo:** Presentaci√≥n del Desarrollo del Modelo

Este script presenta de manera estructurada el proceso completo de desarrollo
del modelo de Machine Learning, siguiendo los 10 pasos fundamentales:

1. Objetivo del modelo
2. Descripci√≥n del dataset (X e y)
3. Preprocesamiento
4. Divisi√≥n Train/Test
5. Selecci√≥n del algoritmo elegido
6. Entrenamiento del modelo (.fit())
7. Predicciones (.predict())
8. M√©tricas de evaluaci√≥n
9. Modelo final implementado
10. Gr√°ficos y conclusiones
"""

import os
import sys
from pathlib import Path
import pandas as pd
import numpy as np

class DemoDesarrolloModelo:
    """
    Clase para presentar el desarrollo completo del modelo de Machine Learning.
    
    Presenta de manera estructurada todos los pasos del proceso de desarrollo,
    desde el objetivo hasta las conclusiones finales.
    """
    
    def __init__(self):
        """Inicializar la demo de desarrollo del modelo."""
        # Manejar el caso cuando se ejecuta con exec() donde __file__ no est√° definido
        try:
            base_path = Path(__file__).parent
        except NameError:
            # Si __file__ no est√° definido, usar el directorio actual
            base_path = Path(os.getcwd())
            # Si no estamos en el directorio correcto, buscar
            if not (base_path / "demo_desarrollo_modelo.py").exists():
                posibles = [
                    base_path,
                    base_path.parent,
                    base_path.parent.parent / "Enith Gicela Vargas Vargas - Proyecto Aurelion",
                ]
                for p in posibles:
                    if p.exists() and (p / "demo_desarrollo_modelo.py").exists():
                        base_path = p
                        break
        
        self.ruta_proyecto = base_path.parent.parent
        self.ruta_datos = self.ruta_proyecto / "Datos Proyecto" / "Base de datos_Tienda_Aurelion" / "Base de datos"
        self.dataset = None
        
    def mostrar_banner(self):
        """Mostrar banner principal."""
        print("=" * 80)
        print("ü§ñ DEMO ASINCR√ìNICA - DESARROLLO DEL MODELO - PROYECTO AURELION")
        print("=" * 80)
        print("üë§ Autor: Enith Gicela Vargas Vargas")
        print("üéì Curso: AI Fundamentals - Guayerd - IBM Skills Build")
        print("üìÖ Fecha: Noviembre 2025")
        print("=" * 80)
        print()
    
    def paso_1_objetivo_modelo(self):
        """Paso 1: Objetivo del modelo."""
        print("=" * 80)
        print("1Ô∏è‚É£  OBJETIVO DEL MODELO")
        print("=" * 80)
        print()
        print("OBJETIVO PRINCIPAL:")
        print("Desarrollar modelos de Machine Learning para predecir y analizar")
        print("el comportamiento de ventas en la Tienda Aurelion.")
        print()
        print("OBJETIVOS ESPEC√çFICOS:")
        print()
        print("üìä REGRESI√ìN:")
        print("   ‚Ä¢ Predecir el importe de ventas bas√°ndose en caracter√≠sticas")
        print("     como cantidad, precio unitario, categor√≠a, medio de pago, etc.")
        print("   ‚Ä¢ Modelo: Random Forest Regressor")
        print("   ‚Ä¢ M√©trica objetivo: R¬≤ > 0.95 (95% de variabilidad explicada)")
        print()
        print("üéØ CLASIFICACI√ìN:")
        print("   ‚Ä¢ Clasificar clientes en segmentos (Bajo, Medio, Alto) seg√∫n")
        print("     su comportamiento de compra")
        print("   ‚Ä¢ Modelo: SVC / Logistic Regression")
        print("   ‚Ä¢ M√©trica objetivo: Accuracy > 0.85 (85% de precisi√≥n)")
        print()
        print("üîç CLUSTERING:")
        print("   ‚Ä¢ Agrupar transacciones similares para identificar patrones")
        print("     de comportamiento")
        print("   ‚Ä¢ Modelo: K-Means Clustering")
        print("   ‚Ä¢ Objetivo: Identificar 3 grupos naturales de transacciones")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_2_descripcion_dataset(self):
        """Paso 2: Descripci√≥n del dataset (X e y)."""
        print("=" * 80)
        print("2Ô∏è‚É£  DESCRIPCI√ìN DEL DATASET (X e y)")
        print("=" * 80)
        print()
        
        # Intentar cargar datos para mostrar informaci√≥n espec√≠fica
        try:
            if self.ruta_datos.exists():
                df_detalle = pd.read_excel(self.ruta_datos / "detalle_ventas.xlsx")
                df_productos = pd.read_excel(self.ruta_datos / "productos.xlsx")
                df_ventas = pd.read_excel(self.ruta_datos / "ventas.xlsx")
                df_clientes = pd.read_excel(self.ruta_datos / "clientes.xlsx")
                
                num_registros = len(df_detalle)
                num_productos = len(df_productos)
                num_ventas = len(df_ventas)
                num_clientes = len(df_clientes)
                
                print("üìä ESTRUCTURA DEL DATASET:")
                print(f"   ‚Ä¢ Total de registros: {num_registros:,} l√≠neas de detalle")
                print(f"   ‚Ä¢ Clientes √∫nicos: {num_clientes:,}")
                print(f"   ‚Ä¢ Productos √∫nicos: {num_productos:,}")
                print(f"   ‚Ä¢ Ventas √∫nicas: {num_ventas:,}")
                print()
        except Exception as e:
            print("   ‚ö†Ô∏è  No se pudieron cargar los datos espec√≠ficos")
            print(f"   Error: {str(e)}")
            print()
        
        print("üìã VARIABLES PREDICTORAS (X - Features):")
        print()
        print("   Variables Num√©ricas:")
        print("   ‚Ä¢ cantidad: Cantidad de productos por l√≠nea de venta (1-5)")
        print("   ‚Ä¢ precio_unitario_detalle: Precio unitario del producto")
        print("   ‚Ä¢ importe: Importe total de la l√≠nea (variable objetivo para regresi√≥n)")
        print()
        print("   Variables Categ√≥ricas (codificadas):")
        print("   ‚Ä¢ categoria: Categor√≠a del producto (Alimentos, Limpieza)")
        print("   ‚Ä¢ medio_pago: M√©todo de pago (efectivo, tarjeta, qr, transferencia)")
        print("   ‚Ä¢ ciudad: Ciudad del cliente (6 ciudades diferentes)")
        print("   ‚Ä¢ edad_cliente: Edad del cliente")
        print("   ‚Ä¢ genero_cliente: G√©nero del cliente")
        print()
        print("üéØ VARIABLES OBJETIVO (y - Target):")
        print()
        print("   Para REGRESI√ìN:")
        print("   ‚Ä¢ y = importe (variable continua)")
        print("   ‚Ä¢ Objetivo: Predecir el importe de una venta")
        print()
        print("   Para CLASIFICACI√ìN:")
        print("   ‚Ä¢ y = segmento_cliente (variable categ√≥rica: Bajo, Medio, Alto)")
        print("   ‚Ä¢ Objetivo: Clasificar clientes en segmentos")
        print()
        print("   Para CLUSTERING:")
        print("   ‚Ä¢ No hay variable objetivo (aprendizaje no supervisado)")
        print("   ‚Ä¢ Features: cantidad, precio_unitario_detalle, importe")
        print()
        print("üìê DIMENSIONES FINALES:")
        print("   ‚Ä¢ Dataset final: 343 registros √ó 27 columnas")
        print("   ‚Ä¢ Features (X): ~12-15 variables predictoras")
        print("   ‚Ä¢ Target (y): 1 variable objetivo (seg√∫n el tipo de problema)")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_3_preprocesamiento(self):
        """Paso 3: Preprocesamiento."""
        print("=" * 80)
        print("3Ô∏è‚É£  PREPROCESAMIENTO")
        print("=" * 80)
        print()
        print("üîß T√âCNICAS APLICADAS:")
        print()
        print("1. IMPUTACI√ìN DE VALORES FALTANTES:")
        print("   ‚Ä¢ Mediana: Para distribuciones sesgadas (skewness > 1)")
        print("   ‚Ä¢ Media: Para distribuciones normales (skewness ‚â§ 1)")
        print("   ‚Ä¢ Moda: Para variables categ√≥ricas")
        print("   ‚Ä¢ Resultado: 0 valores nulos (100% completitud)")
        print()
        print("2. TRATAMIENTO DE OUTLIERS:")
        print("   ‚Ä¢ M√©todo: Winsorization (limitaci√≥n a percentiles 5 y 95)")
        print("   ‚Ä¢ Outliers detectados: 7 en variable 'importe' (2.0%)")
        print("   ‚Ä¢ Resultado: Outliers tratados sin p√©rdida de informaci√≥n")
        print()
        print("3. NORMALIZACI√ìN DE VARIABLES NUM√âRICAS:")
        print("   ‚Ä¢ StandardScaler: Para 'importe' (media=0, std=1)")
        print("   ‚Ä¢ MinMaxScaler: Para 'cantidad' y 'precio_unitario' (rango [0,1])")
        print("   ‚Ä¢ Selecci√≥n autom√°tica basada en skewness")
        print()
        print("4. CODIFICACI√ìN DE VARIABLES CATEG√ìRICAS:")
        print("   ‚Ä¢ OneHot Encoding: categoria (2 columnas), medio_pago (4 columnas)")
        print("   ‚Ä¢ Binary Encoding: ciudad (6 categor√≠as)")
        print("   ‚Ä¢ Resultado: Todas las variables son num√©ricas")
        print()
        print("5. MERGE DE TABLAS:")
        print("   ‚Ä¢ LEFT JOIN entre ventas, clientes, productos y detalle_ventas")
        print("   ‚Ä¢ Validaci√≥n de integridad referencial")
        print("   ‚Ä¢ Resultado: Dataset unificado con 343 registros √ó 27 columnas")
        print()
        print("‚úÖ RESULTADO FINAL:")
        print("   ‚Ä¢ Dataset completamente limpio y normalizado")
        print("   ‚Ä¢ 0 valores nulos")
        print("   ‚Ä¢ Todas las variables en escalas comparables")
        print("   ‚Ä¢ Listo para Machine Learning")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_4_division_train_test(self):
        """Paso 4: Divisi√≥n Train/Test."""
        print("=" * 80)
        print("4Ô∏è‚É£  DIVISI√ìN TRAIN/TEST")
        print("=" * 80)
        print()
        print("üìä M√âTODO UTILIZADO: Holdout Method (M√©todo de Retenci√≥n)")
        print()
        print("üîß IMPLEMENTACI√ìN:")
        print("   ‚Ä¢ Funci√≥n: train_test_split() de scikit-learn")
        print("   ‚Ä¢ Proporci√≥n: 80% entrenamiento / 20% prueba")
        print("   ‚Ä¢ random_state: 42 (para reproducibilidad)")
        print("   ‚Ä¢ Estratificaci√≥n: S√≠ (para clasificaci√≥n)")
        print()
        print("üìê DIVISI√ìN DE DATOS:")
        print("   ‚Ä¢ Total de registros: 343")
        print("   ‚Ä¢ Conjunto de Entrenamiento (Train):")
        print("     - X_train: 274 registros (80%)")
        print("     - y_train: 274 registros (80%)")
        print("   ‚Ä¢ Conjunto de Prueba (Test/Holdout):")
        print("     - X_test: 69 registros (20%)")
        print("     - y_test: 69 registros (20%)")
        print()
        print("üéØ PROP√ìSITO:")
        print("   ‚Ä¢ Train: Entrenar el modelo (ajustar par√°metros)")
        print("   ‚Ä¢ Test: Evaluar la generalizaci√≥n (datos nunca vistos)")
        print()
        print("‚úÖ VALIDACI√ìN ADICIONAL:")
        print("   ‚Ä¢ K-Fold Cross-Validation (K=5) para validaci√≥n robusta")
        print("   ‚Ä¢ 5 divisiones diferentes para mayor confiabilidad")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_5_seleccion_algoritmo(self):
        """Paso 5: Selecci√≥n del algoritmo elegido."""
        print("=" * 80)
        print("5Ô∏è‚É£  SELECCI√ìN DEL ALGORITMO ELEGIDO")
        print("=" * 80)
        print()
        print("üîç ESTRATEGIA DE SELECCI√ìN:")
        print("   Se implementaron m√∫ltiples algoritmos para comparar rendimiento")
        print("   y seleccionar el mejor para cada tipo de problema.")
        print()
        print("üìä ALGORITMOS PROBADOS:")
        print()
        print("   REGRESI√ìN:")
        print("   1. Linear Regression")
        print("      ‚Ä¢ R¬≤ = 0.8499 (84.99%)")
        print("      ‚Ä¢ Modelo baseline simple e interpretable")
        print()
        print("   2. Random Forest Regressor ‚≠ê MEJOR")
        print("      ‚Ä¢ R¬≤ = 0.9962 (99.62%)")
        print("      ‚Ä¢ n_estimators = 100")
        print("      ‚Ä¢ Maneja relaciones no lineales y complejas")
        print()
        print("   3. SVR (Support Vector Regression)")
        print("      ‚Ä¢ R¬≤ = 0.9918 (99.18%)")
        print("      ‚Ä¢ Kernel RBF para relaciones no lineales")
        print()
        print("   CLASIFICACI√ìN:")
        print("   1. Logistic Regression ‚≠ê MEJOR")
        print("      ‚Ä¢ Accuracy = 0.8841 (88.41%)")
        print("      ‚Ä¢ max_iter = 1000, solver = 'lbfgs'")
        print("      ‚Ä¢ Interpretable, proporciona probabilidades")
        print()
        print("   2. Random Forest Classifier")
        print("      ‚Ä¢ Accuracy = 0.8261 (82.61%)")
        print("      ‚Ä¢ Puede sobreajustar")
        print()
        print("   3. SVC (Support Vector Classifier) ‚≠ê MEJOR")
        print("      ‚Ä¢ Accuracy = 0.8841 (88.41%)")
        print("      ‚Ä¢ Igual rendimiento que Logistic Regression")
        print("      ‚Ä¢ Buena generalizaci√≥n")
        print()
        print("   CLUSTERING:")
        print("   1. K-Means ‚≠ê ELEGIDO")
        print("      ‚Ä¢ n_clusters = 3")
        print("      ‚Ä¢ Silhouette Score = 0.3863")
        print("      ‚Ä¢ Simple, r√°pido, interpretable")
        print()
        print("   2. DBSCAN")
        print("      ‚Ä¢ 5 clusters detectados autom√°ticamente")
        print("      ‚Ä¢ Detecta outliers")
        print()
        print("‚úÖ ALGORITMO FINAL ELEGIDO:")
        print("   ‚Ä¢ Regresi√≥n: Random Forest Regressor (R¬≤ = 99.62%)")
        print("   ‚Ä¢ Clasificaci√≥n: SVC / Logistic Regression (Accuracy = 88.41%)")
        print("   ‚Ä¢ Clustering: K-Means (3 clusters, Silhouette = 0.3863)")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_6_entrenamiento(self):
        """Paso 6: Entrenamiento del modelo (.fit())."""
        print("=" * 80)
        print("6Ô∏è‚É£  ENTRENAMIENTO DEL MODELO (.fit())")
        print("=" * 80)
        print()
        print("üîß M√âTODO UTILIZADO: .fit(X_train, y_train)")
        print()
        print("üìù C√ìDIGO DE EJEMPLO:")
        print("```python")
        print("# 1. Preparar datos")
        print("X_train, X_test, y_train, y_test = train_test_split(")
        print("    X, y, test_size=0.2, random_state=42")
        print(")")
        print()
        print("# 2. Crear modelo")
        print("modelo = RandomForestRegressor(")
        print("    n_estimators=100,")
        print("    random_state=42")
        print(")")
        print()
        print("# 3. Entrenar con .fit()")
        print("modelo.fit(X_train, y_train)")
        print("```")
        print()
        print("‚öôÔ∏è  PROCESO INTERNO DE .fit():")
        print("   1. El modelo analiza la relaci√≥n entre X_train e y_train")
        print("   2. Calcula los par√°metros √≥ptimos:")
        print("      ‚Ä¢ Regresi√≥n: Coeficientes, estructura de √°rboles")
        print("      ‚Ä¢ Clasificaci√≥n: Pesos, fronteras de decisi√≥n")
        print("      ‚Ä¢ Clustering: Centroides, asignaci√≥n de clusters")
        print("   3. Ajusta el modelo para minimizar el error:")
        print("      ‚Ä¢ Regresi√≥n: Minimiza MSE (Mean Squared Error)")
        print("      ‚Ä¢ Clasificaci√≥n: Minimiza Cross-Entropy Loss")
        print("   4. Nunca ve los datos de prueba durante este proceso")
        print()
        print("üìä RESULTADOS DEL ENTRENAMIENTO:")
        print()
        print("   REGRESI√ìN (Random Forest):")
        print("   ‚Ä¢ R¬≤ en entrenamiento: 0.9997 (99.97%)")
        print("   ‚Ä¢ R¬≤ en prueba: 0.9962 (99.62%)")
        print("   ‚Ä¢ Diferencia: 0.0035 (muy peque√±a ‚Üí no hay overfitting)")
        print()
        print("   CLASIFICACI√ìN (SVC/Logistic):")
        print("   ‚Ä¢ Accuracy en entrenamiento: 0.8869 (88.69%)")
        print("   ‚Ä¢ Accuracy en prueba: 0.8841 (88.41%)")
        print("   ‚Ä¢ Diferencia: 0.0028 (muy peque√±a ‚Üí buena generalizaci√≥n)")
        print()
        print("   CLUSTERING (K-Means):")
        print("   ‚Ä¢ 3 clusters identificados")
        print("   ‚Ä¢ 343 muestras distribuidas entre los 3 clusters")
        print("   ‚Ä¢ Silhouette Score: 0.3863")
        print("   ‚Ä¢ Centroides calculados para cada cluster")
        print()
        print("‚úÖ MODELO ENTRENADO Y LISTO:")
        print("   ‚Ä¢ Par√°metros ajustados a los datos de entrenamiento")
        print("   ‚Ä¢ Listo para hacer predicciones con .predict()")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_7_predicciones(self):
        """Paso 7: Predicciones (.predict())."""
        print("=" * 80)
        print("7Ô∏è‚É£  PREDICCIONES (.predict())")
        print("=" * 80)
        print()
        print("üîß M√âTODO UTILIZADO: .predict(X_test)")
        print()
        print("üìù C√ìDIGO DE EJEMPLO:")
        print("```python")
        print("# Modelo ya entrenado con .fit()")
        print("modelo.fit(X_train, y_train)")
        print()
        print("# Hacer predicciones con .predict()")
        print("y_pred_train = modelo.predict(X_train)  # Predicciones en entrenamiento")
        print("y_pred_test = modelo.predict(X_test)    # Predicciones en prueba")
        print("```")
        print()
        print("‚öôÔ∏è  PROCESO INTERNO DE .predict():")
        print("   1. Recibe datos nuevos (X_test) que el modelo nunca ha visto")
        print("   2. Usa los par√°metros aprendidos durante .fit()")
        print("   3. Aplica las reglas/patrones aprendidos a los nuevos datos")
        print("   4. Genera predicciones (y_pred) basadas en lo aprendido")
        print()
        print("üìä EJEMPLO DE PREDICCI√ìN EN AURELION:")
        print()
        print("   REGRESI√ìN:")
        print("   ‚Ä¢ Input (X): cantidad=4, precio=2500, categoria='Alimentos', ...")
        print("   ‚Ä¢ Output (y_pred): importe_predicho = $10,000")
        print("   ‚Ä¢ Comparaci√≥n: importe_real = $9,800")
        print("   ‚Ä¢ Error: $200 (2% de error)")
        print()
        print("   CLASIFICACI√ìN:")
        print("   ‚Ä¢ Input (X): caracter√≠sticas del cliente")
        print("   ‚Ä¢ Output (y_pred): segmento_predicho = 'Alto'")
        print("   ‚Ä¢ Comparaci√≥n: segmento_real = 'Alto'")
        print("   ‚Ä¢ Resultado: ‚úÖ Predicci√≥n correcta")
        print()
        print("   CLUSTERING:")
        print("   ‚Ä¢ Input (X): cantidad, precio_unitario, importe")
        print("   ‚Ä¢ Output (y_pred): cluster = 2")
        print("   ‚Ä¢ Interpretaci√≥n: Transacci√≥n pertenece al cluster 2")
        print()
        print("üìà USO DE PREDICCIONES:")
        print("   ‚Ä¢ Evaluar rendimiento del modelo")
        print("   ‚Ä¢ Comparar predicciones con valores reales")
        print("   ‚Ä¢ Calcular m√©tricas de evaluaci√≥n")
        print("   ‚Ä¢ Hacer predicciones sobre datos nuevos en producci√≥n")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_8_metricas_evaluacion(self):
        """Paso 8: M√©tricas de evaluaci√≥n."""
        print("=" * 80)
        print("8Ô∏è‚É£  M√âTRICAS DE EVALUACI√ìN")
        print("=" * 80)
        print()
        print("üìä M√âTRICAS PARA REGRESI√ìN:")
        print()
        print("   1. R¬≤ (Coeficiente de Determinaci√≥n):")
        print("      ‚Ä¢ F√≥rmula: R¬≤ = 1 - (SS_res / SS_tot)")
        print("      ‚Ä¢ Rango: -‚àû a 1 (ideal: 1.0)")
        print("      ‚Ä¢ Interpretaci√≥n: % de varianza explicada")
        print("      ‚Ä¢ Resultado: R¬≤ = 0.9962 (99.62%) ‚≠ê Excelente")
        print()
        print("   2. MSE (Mean Squared Error):")
        print("      ‚Ä¢ F√≥rmula: MSE = (1/n) √ó Œ£(y_real - y_pred)¬≤")
        print("      ‚Ä¢ Interpretaci√≥n: Error promedio al cuadrado")
        print("      ‚Ä¢ Resultado: MSE muy bajo (errores peque√±os)")
        print()
        print("   3. RMSE (Root Mean Squared Error):")
        print("      ‚Ä¢ F√≥rmula: RMSE = ‚àöMSE")
        print("      ‚Ä¢ Interpretaci√≥n: Error promedio en unidades originales")
        print()
        print("   4. MAE (Mean Absolute Error):")
        print("      ‚Ä¢ F√≥rmula: MAE = (1/n) √ó Œ£|y_real - y_pred|")
        print("      ‚Ä¢ Interpretaci√≥n: Error promedio absoluto")
        print()
        print("   5. Cross-Validation (K-Fold CV, K=5):")
        print("      ‚Ä¢ R¬≤ promedio: 0.9981")
        print("      ‚Ä¢ Desviaci√≥n est√°ndar: ¬±0.0022")
        print("      ‚Ä¢ Interpretaci√≥n: Modelo muy consistente")
        print("      ‚Ä¢ R¬≤ entrenamiento: 0.9997 (99.97%)")
        print()
        print("üìä M√âTRICAS PARA CLASIFICACI√ìN:")
        print()
        print("   1. Accuracy (Precisi√≥n Global):")
        print("      ‚Ä¢ F√≥rmula: (TP + TN) / (TP + TN + FP + FN)")
        print("      ‚Ä¢ Resultado: 0.8841 (88.41%) ‚≠ê Muy bueno")
        print()
        print("   2. Precision (Precisi√≥n por Clase):")
        print("      ‚Ä¢ F√≥rmula: TP / (TP + FP)")
        print("      ‚Ä¢ Interpretaci√≥n: De las predicciones positivas, cu√°ntas son correctas")
        print("      ‚Ä¢ Resultado: ~0.89 (89%)")
        print()
        print("   3. Recall (Sensibilidad):")
        print("      ‚Ä¢ F√≥rmula: TP / (TP + FN)")
        print("      ‚Ä¢ Interpretaci√≥n: De los casos reales, cu√°ntos se detectaron")
        print("      ‚Ä¢ Resultado: ~0.83 (83%)")
        print()
        print("   4. F1-Score:")
        print("      ‚Ä¢ F√≥rmula: 2 √ó (Precision √ó Recall) / (Precision + Recall)")
        print("      ‚Ä¢ Interpretaci√≥n: Balance entre Precision y Recall")
        print("      ‚Ä¢ Resultado: ~0.86 (86%)")
        print()
        print("   5. Matriz de Confusi√≥n:")
        print("      ‚Ä¢ Muestra predicciones correctas e incorrectas por clase")
        print("      ‚Ä¢ 88 predicciones correctas de 100 totales")
        print()
        print("üìä M√âTRICAS PARA CLUSTERING:")
        print()
        print("   1. Silhouette Score:")
        print("      ‚Ä¢ Rango: -1 a 1 (ideal: cercano a 1)")
        print("      ‚Ä¢ Resultado: 0.3863 ‚≠ê Aceptable")
        print("      ‚Ä¢ Interpretaci√≥n: Clusters moderadamente bien definidos")
        print()
        print("   2. N√∫mero de Clusters:")
        print("      ‚Ä¢ K-Means: 3 clusters")
        print("      ‚Ä¢ DBSCAN: 5 clusters detectados autom√°ticamente")
        print()
        print("‚úÖ EVALUACI√ìN GENERAL:")
        print("   ‚Ä¢ Regresi√≥n: Excelente (R¬≤ = 99.62%)")
        print("   ‚Ä¢ Clasificaci√≥n: Muy buena (Accuracy = 88.41%)")
        print("   ‚Ä¢ Clustering: Aceptable (Silhouette = 0.3863)")
        print("   ‚Ä¢ No hay overfitting (train ‚âà test)")
        print("   ‚Ä¢ Modelo generaliza bien a datos nuevos")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_9_modelo_final(self):
        """Paso 9: Modelo final implementado."""
        print("=" * 80)
        print("9Ô∏è‚É£  MODELO FINAL IMPLEMENTADO")
        print("=" * 80)
        print()
        print("‚úÖ MODELOS FINALES SELECCIONADOS:")
        print()
        print("üìä REGRESI√ìN - Random Forest Regressor:")
        print("```python")
        print("from sklearn.ensemble import RandomForestRegressor")
        print()
        print("modelo_regresion = RandomForestRegressor(")
        print("    n_estimators=100,      # 100 √°rboles")
        print("    random_state=42,       # Reproducibilidad")
        print("    max_depth=None,        # Sin l√≠mite de profundidad")
        print("    min_samples_split=2,   # M√≠nimo de muestras para dividir")
        print("    min_samples_leaf=1     # M√≠nimo de muestras en hoja")
        print(")")
        print()
        print("# Entrenar")
        print("modelo_regresion.fit(X_train, y_train)")
        print()
        print("# Predecir")
        print("y_pred = modelo_regresion.predict(X_test)")
        print("```")
        print()
        print("   ‚Ä¢ R¬≤ = 0.9962 (99.62%)")
        print("   ‚Ä¢ MSE muy bajo")
        print("   ‚Ä¢ Generaliza excelentemente")
        print()
        print("üéØ CLASIFICACI√ìN - SVC / Logistic Regression:")
        print("```python")
        print("from sklearn.svm import SVC")
        print("from sklearn.linear_model import LogisticRegression")
        print()
        print("# Opci√≥n 1: SVC")
        print("modelo_clasificacion = SVC(random_state=42)")
        print()
        print("# Opci√≥n 2: Logistic Regression")
        print("modelo_clasificacion = LogisticRegression(")
        print("    random_state=42,")
        print("    max_iter=1000,")
        print("    solver='lbfgs'")
        print(")")
        print()
        print("# Entrenar")
        print("modelo_clasificacion.fit(X_train, y_train)")
        print()
        print("# Predecir")
        print("y_pred = modelo_clasificacion.predict(X_test)")
        print("```")
        print()
        print("   ‚Ä¢ Accuracy = 0.8841 (88.41%)")
        print("   ‚Ä¢ Precision = ~0.89 (89%)")
        print("   ‚Ä¢ Recall = ~0.83 (83%)")
        print()
        print("üîç CLUSTERING - K-Means:")
        print("```python")
        print("from sklearn.cluster import KMeans")
        print()
        print("modelo_clustering = KMeans(")
        print("    n_clusters=3,          # 3 grupos")
        print("    random_state=42,       # Reproducibilidad")
        print("    n_init=10              # 10 inicializaciones")
        print(")")
        print()
        print("# Entrenar y predecir")
        print("clusters = modelo_clustering.fit_predict(X)")
        print("```")
        print()
        print("   ‚Ä¢ 3 clusters identificados")
        print("   ‚Ä¢ Silhouette Score = 0.3863")
        print("   ‚Ä¢ Centroides calculados para cada cluster")
        print()
        print("üíæ GUARDADO DE MODELOS:")
        print("   ‚Ä¢ Modelos guardados en formato .pkl")
        print("   ‚Ä¢ Ubicaci√≥n: resultados/modelos/")
        print("   ‚Ä¢ Permite reutilizar modelos sin reentrenar")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para continuar al siguiente paso...")
        print()
    
    def paso_10_graficos_conclusiones(self):
        """Paso 10: Gr√°ficos y conclusiones."""
        print("=" * 80)
        print("üîü GR√ÅFICOS Y CONCLUSIONES")
        print("=" * 80)
        print()
        print("üìä VISUALIZACIONES GENERADAS:")
        print()
        print("   1. COMPARACI√ìN DE MODELOS:")
        print("      ‚Ä¢ Gr√°ficos de barras comparando R¬≤/Accuracy entre modelos")
        print("      ‚Ä¢ Visualizaci√≥n de m√©tricas train vs test")
        print()
        print("   2. PREDICCIONES VS VALORES REALES:")
        print("      ‚Ä¢ Scatter plots: y_pred vs y_real")
        print("      ‚Ä¢ L√≠nea de regresi√≥n perfecta (y=x)")
        print("      ‚Ä¢ Distribuci√≥n de errores")
        print()
        print("   3. MATRICES DE CONFUSI√ìN:")
        print("      ‚Ä¢ Heatmaps mostrando predicciones correctas/incorrectas")
        print("      ‚Ä¢ An√°lisis por clase (Bajo, Medio, Alto)")
        print()
        print("   4. CLUSTERING:")
        print("      ‚Ä¢ Visualizaci√≥n 2D/3D de clusters")
        print("      ‚Ä¢ Centroides marcados")
        print("      ‚Ä¢ Distribuci√≥n de muestras por cluster")
        print()
        print("   5. IMPORTANCIA DE CARACTER√çSTICAS:")
        print("      ‚Ä¢ Feature importance de Random Forest")
        print("      ‚Ä¢ Variables m√°s relevantes para las predicciones")
        print()
        print("   6. DISTRIBUCI√ìN DE ERRORES:")
        print("      ‚Ä¢ Histogramas de residuos")
        print("      ‚Ä¢ An√°lisis de outliers en predicciones")
        print()
        print("   7. VALIDACI√ìN CRUZADA:")
        print("      ‚Ä¢ Scores por fold")
        print("      ‚Ä¢ Variabilidad entre divisiones")
        print()
        print("üìà TOTAL DE GR√ÅFICOS GENERADOS: 24 visualizaciones avanzadas")
        print()
        print("=" * 80)
        print("üìù CONCLUSIONES")
        print("=" * 80)
        print()
        print("‚úÖ LOGROS PRINCIPALES:")
        print()
        print("   1. MODELOS DE ALTA CALIDAD:")
        print("      ‚Ä¢ Regresi√≥n: R¬≤ = 99.62% (excelente)")
        print("      ‚Ä¢ Clasificaci√≥n: Accuracy = 88.41% (muy bueno)")
        print("      ‚Ä¢ Clustering: 3 grupos bien definidos")
        print()
        print("   2. PREPROCESAMIENTO EXITOSO:")
        print("      ‚Ä¢ 0 valores nulos")
        print("      ‚Ä¢ Outliers tratados adecuadamente")
        print("      ‚Ä¢ Variables normalizadas y codificadas")
        print()
        print("   3. GENERALIZACI√ìN EXCELENTE:")
        print("      ‚Ä¢ Train y test tienen rendimiento similar")
        print("      ‚Ä¢ No hay overfitting")
        print("      ‚Ä¢ Modelo funciona bien en datos nuevos")
        print()
        print("   4. VALIDACI√ìN ROBUSTA:")
        print("      ‚Ä¢ Holdout method (80/20)")
        print("      ‚Ä¢ K-Fold Cross-Validation (K=5)")
        print("      ‚Ä¢ Resultados consistentes")
        print()
        print("üéØ APLICACIONES PR√ÅCTICAS:")
        print()
        print("   ‚Ä¢ PREDICCI√ìN DE VENTAS:")
        print("     - Predecir importe de ventas futuras")
        print("     - Optimizar inventario")
        print("     - Planificar estrategias de precios")
        print()
        print("   ‚Ä¢ SEGMENTACI√ìN DE CLIENTES:")
        print("     - Identificar clientes de alto valor")
        print("     - Personalizar campa√±as de marketing")
        print("     - Mejorar retenci√≥n de clientes")
        print()
        print("   ‚Ä¢ AN√ÅLISIS DE PATRONES:")
        print("     - Identificar grupos de transacciones similares")
        print("     - Detectar comportamientos an√≥malos")
        print("     - Optimizar mix de productos")
        print()
        print("üìä IMPACTO EN EL NEGOCIO:")
        print("   ‚Ä¢ Mejora en la toma de decisiones basada en datos")
        print("   ‚Ä¢ Optimizaci√≥n de recursos y estrategias")
        print("   ‚Ä¢ Mayor comprensi√≥n del comportamiento del cliente")
        print("   ‚Ä¢ Base s√≥lida para implementaci√≥n en producci√≥n")
        print()
        print("=" * 80)
        print()
        print("‚úÖ DEMO COMPLETADA - DESARROLLO DEL MODELO FINALIZADO")
        print("=" * 80)
        print()
    
    def ejecutar_demo_completa(self):
        """Ejecutar la demo completa del desarrollo del modelo."""
        self.mostrar_banner()
        
        print("üìã Esta demo presenta los 10 pasos del desarrollo del modelo:")
        print()
        print("   1. Objetivo del modelo")
        print("   2. Descripci√≥n del dataset (X e y)")
        print("   3. Preprocesamiento")
        print("   4. Divisi√≥n Train/Test")
        print("   5. Selecci√≥n del algoritmo elegido")
        print("   6. Entrenamiento del modelo (.fit())")
        print("   7. Predicciones (.predict())")
        print("   8. M√©tricas de evaluaci√≥n")
        print("   9. Modelo final implementado")
        print("  10. Gr√°ficos y conclusiones")
        print()
        print("=" * 80)
        print()
        input("‚è∏Ô∏è  Presiona Enter para comenzar la demo...")
        print()
        
        # Ejecutar cada paso
        self.paso_1_objetivo_modelo()
        self.paso_2_descripcion_dataset()
        self.paso_3_preprocesamiento()
        self.paso_4_division_train_test()
        self.paso_5_seleccion_algoritmo()
        self.paso_6_entrenamiento()
        self.paso_7_predicciones()
        self.paso_8_metricas_evaluacion()
        self.paso_9_modelo_final()
        self.paso_10_graficos_conclusiones()


def main():
    """Funci√≥n principal para ejecutar la demo."""
    demo = DemoDesarrolloModelo()
    demo.ejecutar_demo_completa()


if __name__ == "__main__":
    main()

